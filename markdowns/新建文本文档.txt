编码
布尔编码
数字编码 int，uint，位数， bigint，整数运算
浮点数标准和浮点数运算
逻辑编码和逻辑运算（有限的情况下量词可以转化为并和否定）
字符，字符编码和字符串


函数
梯度
炉石中的数学
课本知识考古


汉语中的”数“是个很模糊的概念，你可以说整数是数，分数是数，无理数是数，复数是数，四元数是数；也可以说阿拉伯数字是数，汉字数字是数，易经六十四卦是数；还能说基数是数，序数是数。总之单独一个”数“可以涵盖很多杂七杂八的概念。我这里所说的”数“只是这种种含义中的一种——自然数——也就是全体正整数和零。

一般来说我们用阿拉伯数字来表示数，但是阿拉伯数字本身并不是数，而是一种字。每一个数都是一个抽象的概念，不会因为文字写法而发生改变。举个例子，汉字”二“，英文单词”two“，阿拉伯数字”2“，罗数字”II“表示的都是同一个数，它们都是表示这同一个数的不同的文字。不管你怎么表示，数还是那些数，数不会因为你表示方法的改变而增多或减少。例如以前有的文字系统里没有表示零的专用符号，但用这种文字的人仍然知道五减五就什么都没有了，并不会算出六或者别的什么。虽然没有一个合适的符号来表示，零（或没有）这个概念是可以存在的。从这个角度来说数学比体育更适合用”同一个世界，同一个梦想“当口号。

## 逐个起名

最简单的用文字表示数的方法，无非是像我们给其他抽象概念命名那样，直接给数指派独一无二的字符（或者单词）。例如给表示什么都没有的那个数起名为”零“，给零后边那个数起名为”一“，给一后边那个数起名为”二“……但是这样有一个问题，数是无穷的，要想表示所有数就要无穷的名字。即便我们退而求其次，只给实际用到的数字起名，在一亿都是小目标的现在，按照这种表示方法也至少需要一亿个能相互区别的名字，这是不太现实的（康熙字典才收录了不到五万个字）。

## 位置计数法

既然给数一个一个起名字这条路走不通，我们就换一个思路来考虑。用有限的符号排列起来表示数字。我们先考虑能不能用一个符号来表示数。例如用”0“表示什么都没有，用”00“表示0后边那个数，除了第一个数0以外，其他所有数都是在之前那个数的写法后边加一个“0”。为了方便描述，我们称一个写“0”的地方为一个“位”，就是一个位置的意思。例如“000”有三个位，“00000”有五个位。有了这样的计数法，倒是省掉了给数字一个一个起名字的麻烦，但是当数字比较大的时候就麻烦了，要表示一个上百的数就要画上百个“0”。

看来用一个符号表示数不是一个好办法，我们再来考虑用两个符号来表示数。符号“0”，仍旧按照原来的约定，但是我们用“1”来表示0后边那个数。并且我们仍旧沿用位的概念，当只有一个位 的时候，我们可以排出“0”或者“1”，只有两种情况。当有两个位时，有四种排列“00”，“01”，“10，“”11”。如果我们把全是“0”的那种排列缩写为“0”，把其他排列中从左数第一个“1”之前的“0”全部省略，“00”就相当于一位时候的“0”，“01”就相当于一位时候都“1”。现在考虑三个位的情况，一共有八种排列“000”，“001”，“010”，“011”，“100”，“101”，“110”，“111”，如果应用之前介绍的简化方法，它们分别等价于“0”，“1”，“10”，“11”，“100”，“101”，“110”，“111”。如果有四个位，就有十六种排列。可能你已经发现规律了，每增加一个位，总共个的排列数就是之前的两倍。由于我们关于省略“0”的约定，我们实际上是将各种长度的排列混起来用。因而我们一般不对位数做限制，而是限制所能使用的最多位数。例如我们可以这样说如果最多允许用使用六个位，我们一共能得到六十四种各不相同的排列（排除等价的之后），也就是能表示六十四个数。相比于只用一个符号的情况，这已经改善了很多，用一个符号来表示六十四个数需要六十四个位，比两种符号的情况多用了五十八个位。

## 加法运算

在把数和字符组合对应起来之前，我们先来定义这些字符排列的运算。首先是加法运算，在加法运算之前如果两个字符排列的位数不同，就往短的那一个左边补零直到二者位数相同。然后我们从右往左逐位运算。右侧第一个位没有从更右边的数进上来的数，因而只有四种情况：

1. 这两个相同的位上都是0，结果为0，不进位。
1. 一个为1，一个为0，结果为1，不进位。
1. 一个为0，一个为1，结果为1，不进位。
1. 两个都是1，结果为0，向左边进1。

完成这一位的计算后接着计算左边的一位，从这一位开始需要考虑进位，这就有八种情况：

1. 两个加数的位和进位都为0，结果为0，不进位。
1. 三者中有一个1（三种情况），结果为1，不进位。
1. 三者中有两个1（三种情况），结果为0，进1。
1. 三个都是1，结果为1，进1。

算完这一位后继续往左运算，直到两个加数的最高位算完。如果最高位算完后还进位，记得往结果的最左边加一个位写上1。

这样我们就能得到0加1得1，1加1得10，10加1得11，11加1得100……然后我们建立这些字符排列和数之间的对应关系。“0”表示那个代表没有的数，要表示一个数后边的那个数，就对这个数执行加1操作。其实我们建立的这个计数方法，就是二进制位置计数法。

## 乘法运算

在二进制表示下，

现在我们来说明这种计数法之下的运算。



用这种方法，我们只需要最少两个



## 数是抽象的

每一个数都是一个



按照我们最直观的影响来说什么是数？可能有人会脱口而出”1，2，3，4这样一直数下去，这些都是数“。这种说法提炼一下就是数学上的所谓自然数。

不过，好在我们有一个参照词——”数论“。”论“自然是理论的意思。关于什么的理论呢？关于自然数的理论，简称数论。对比另一个词”数论“



# 字符编码

虽然在学校学习语文课的时候，语言和文字是一起学习的，但实际上语言和文字不完全是一回事。一门语言可以用多种文字记录，一种文字也可以用于记录不同的语言。例如汉字可以用来记录汉语，也可以用来记录日语，而汉语可以用汉字来记录，也可以用拉丁字母（汉语拼音）来记录。具体来说我们语文课上、外语课上学的语法和词汇属于语言，而“ABCD”和“上大人孔乙己”属于文字。我们今天要聊的内容主要是关于文字的，而不是关于语言的。

文字发明至今也有几千年的历史了，如果展开聊，文字也是一个非常大的话题。因此我们仅仅截取历史长河中的一小段，然后再从这一小段中选一个片面来聊。这个一小段中的一个片面，就是文字的数字化。

## 字符和字形

语言的基本单位是词汇，文字的基本单位是单个的符号，或者说字符（Character）。例如拉丁字母“A”就是一个字符，汉字“孔”也是一个字符、数学符号“¬”也是字符。字符其实是一个抽象概念。以拉丁字母A为例，它的不同写法并不影响它是拉丁字母A，黑体**A**、斜体*A*、花体$\mathcal{A}$都是拉丁字母A。我们称这些同一个字符的不同写法为不同的字形（glyph）。

为了进一步说明字符这个概念的抽象性，我们先聊点题外话。我们都知道“爱”是一个抽象的概念。我们可以说拥抱和亲吻都是体现爱这一抽象概念的动作，但不能说亲吻或者拥抱就是爱本身。同样的，我们写在纸上的A、打印出来的A、屏幕上显示的A、你眼里看到的A其实都是字符A的字形。这些字形表示字符A，但是我们不能说这些字形就是字符A本身。字符A本身就是一个抽象概念（就像数学里的1），用什么形式来表示它都是可以的。哪怕你把它写成“B”或者别的什么形式也可以。只要阅读你写下的东西的人和你一样把“B”当作拉丁字母A的一种字形就可以。凯撒密码就是用了这个思路，把A写成“B”，把B写成“C”，把C写成“D”，如此这般，最后再把Z写成“A”。经过这样的变换，CAESAR就写成了“DBFTBS”。友军由于知道加密的方法，所以可以看懂这个单词，但对加密方法一无所知的敌军是看不懂的。

## 字符和数字

数字和字符的情况有点类似。数字也是抽线的概念，例如三个苹果可以表示数字3、三个香蕉也可以表示数字3、三个电脉冲也可以表示数字3，但这些都不是3本身，只是用它们来表示3这个抽象概念而已。我们说计算机可以对数字进行操作，但它是通过操作电信号来表示这一过程的。

现在我们想让处理数字的计算机也能处理字符，实际上只需要在字符和数字这两组抽象概念之间建立一种对应关系就可以。例如我们用数字1表示字符A，在计算机内部用电信号保存了一个数字1就相当于保存了一个字符A（从这个角度来说相当于电信号成了字符的又一种“字形”）。字符和数字之间的这种对应关系就叫做字符编码。举个例子，用数字1表示拉丁字母A，用数字2表示拉丁字母B，一直到用数字26表示拉丁字母Z，这就是一种字符编码。你也可以发挥想象力，创造各种各样的字符编码，比如用1到52内的所有偶数表示小写拉丁字母，奇数表示所有大写拉丁字母，或者编码不从1开始，又或者用素数来为字符编码等等。在不受额外约束的情况下创造一套字符编码其实不是一个难事，但现实中我们需要面对很多约束。

## 前ASCII时代

对于计算机来说，最大的约束就是计算机的容量和算力都是有限的。计算机中最小的数据单位是bit，一个bit可以是0或1两种状态。如果把两个bit放到一起就可以有4种状态，分别能表示0，1，2，3。如果把三个bit放到一起就有8种状态，可以表示0到7的数字。越多的bit就能表示越多的数字，从而就能编码更多字符。但是用更多的bit表示一个字符，也就会造成更大的存储和处理开销。在这样的矛盾之下，人们总是试图用尽量少的bit来编码尽量多的字符——除非状态数实在不够用。

用3 bits编码字符，只能给8个字符编码，用来给有26个字母，大小写加起来有52个字符的拉丁字母编码，肯定是不够的。因此需要继续增加bit数量。当有5个bit的时候，就有32种状态，放下26个大写（或小写）拉丁字母是够用了。为printing telegraph设计的Baudot Code编码就是用五个bit编码了26个（大写）拉丁字母（如图[^1]）。

> printing telegraph我不知道怎么翻译，所以用了英文名称。printing telegraph是一种电报机，和我们电影里经常看见的那种一个人按，然后发出滴滴声的电报机不太一样。传统电报机用dash和dot的组合来传递信息。dash就是一个比较长的滴声，dot就是一个比较短的滴声。那么具体怎么实现发dash和dot呢，全靠发报人手工控制，他按发报键时间长一点就是dash，短一点就是dot。在发报的时候需要先把信件翻译成dash和dot的组合，然后由发报员手工按出去。收报的一方要听dash和dot，然后再把信翻译回来（这还是不加密的情况下）。因此整个过程很麻烦。printing telegraph的好处就在于它的按钮不止一个，每个按钮对应一个字符，你只要按这个按钮一下，它就自动把这个字符对应的那一段滴滴声发出去。收报的时候printing telegraph也不用人工监听，它会自动把收到的内容印出来。总体上printing telegraph就像电报机和打字机结合起来，由发报方的键盘控制收报方的打字机打字。
>
> 早期的printing telegraph用的键盘还是钢琴式的键盘，后来换成了和打字机一样的键盘，于是就改名为teleprinter（或者teletypewriter，简称TTY）。

![Baudot Code](https://upload.wikimedia.org/wikipedia/commons/6/67/Baudot_Code_-_1888_patent_-_chart_only.png)

[^1]:  Baudot Code编码

虽然Baudot Code能编码26个（大写）拉丁字母，但仅仅用字母是没法把日常信件完全打出来的。因为人们在写信的时候还需要句点，逗号，撇号，引号之类的标点符号，有时候还要用一些阿拉伯数字来表示年份，编号，数量等等。这时候只有32种状态的5 bits编码肯定是不够用了。同样用于printing telegraph的Murray Code用了shift codes来扩充编码的表达能力。但实际上有更简单的办法——再加几个bit。

> 可能你会想，我们的编码就是要用数字表示字符，为什么表示数字的阿拉伯数字还需要再编码。这里解释一下：阿拉伯数字本身是一种表示数的字符，就像汉语种的“一”，“二”，“三”都是字符一样。既然是字符自然需要编码。如果你想在信件中出现数字的时候不用编码的字符表示，而是直接用数字表示，就会造成混淆。因为你不知道32表示的是数字32还是数字32编码的那个字符。

## ASCII编码

到了ASCII编码的时候（此时printing telegraph已经进化为teleprinter），用了7 bits编码（）。7 bits一共有128种状态，不仅能编码26个大写拉丁字母，还能编码26个小写拉丁字母、10个阿拉伯数字字符、一堆标点符号和一些特殊符号，总共编码了95个可打印字符（如图[^2]）。所谓的可打印字符就是说在打字机上有一个对应的铅字用来印刷它。例如teleprinter收到编码0X23，就会用刻着井号的那个铅字往纸上印一下，所以井号就是个可打印字符。可打印字符里比较特殊的是空格，虽然什么也没有印出来，但是占了一个字符的位置，所以它也被视为是一个可打印字符。

![ASCII](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4f/ASCII_Code_Chart.svg/1920px-ASCII_Code_Chart.svg.png)

[^2]: ASCII Code Chart

ASCII编码中除了可打印字符以外，剩下的称为控制字符。控制字符不会直接让teleprinter打印一个字符出来，而是让teleprinter做一些动作。例如0X07这个编码可以让teleprinter上的电铃响一下，0X0A则让打印纸上移一行，诸如此类。不过teleprinter的时代已经过去很久了这些控制字符由很多已经用不着了。

有了ASCII之后，似乎日常英语书信基本都可以编码为数字了。但拉丁字母可不仅仅是英语中用到的那26个，世界上的文字也不是只有拉丁字母一种。





（不妨把这样的组合叫做2 bits单元）。如果把四个bit（也可以看作两个2 bits单元的组合）放到一起就有16种状态可以表示0到15的数（用十六进制写法就是从0到F）。

你不能用圆周率这种无穷无尽的数字来给字符编码，因为计算机的存储空间放不下，也处理不了。单个字符的编码也是数字越小越好，因为



把编号和存储分开







更准确一点来说，实际上我们写出来的，印出来的，屏幕上显示的都是字形而非字符本身。这些字形表示字符，但由于字符是一个抽象概念，你不能

有时候字形之间的差距可能会非常大，但是我们仍然认为这些字形属于





字符其实是一个抽象概念，不容易直观地对它进行描述，所以我们先举几个例子。





文本文件是最基本，最常用，也非常简单的一类的文件。浏览和编辑文本文件是基础中的基础。  为了和图文混排，字体样式繁多的文本类文件相区别，我们称不包含任何格式信息或非图像信息（仅仅包含编码为二进制数的文字符号）的文本文件为纯文本（Plain Text）。具体来说，在Word类软件中所编辑的就是富文本，而大多数程序源码则是以纯文本的形式编写和存储的。  当然，如果你喜欢也可以用纯文本来写小说，记日记什么的。只不过，大多数普通用户都选择了界面更为友好的软件。所以目前，纯文本的编辑和纯文本相关不再是计算机用户的必修课。只有做编程相关工作的人才会接触多一些。  

这一篇文章将介绍一些和纯文本相关的知识点。下一期我们来聊几款编辑纯文本的工具。  

字符编码  字符是人类的发明，用平面图案来表示、记录信息。计算机发明后，人类开始使用计算机处理文字信息。具体做法当然不是试图让计算机仿照人类写字直接在磁盘上刻出人类能识别的符号。而是在常用的字符和计算机所能处理的二进制数之间建立映射关系。这样就能把处理字符串（字符组成的序列）的问题转化为算术和逻辑的问题。  

不过，由于语言、国别、维护团体等方面的原因，历史上出现过众多的编码方案。不同的编码方案中同一个字符可能对应不同的数字，或者有的字符在有的方案中就根本没有被编码。这一度给信息交流带来过麻烦。不过现在这种问题越来越不算是一个问题。目前需要重点了解的只有——ASCII和UTF-8。其中UTF-8还兼容ASCII，所以，其实只需要了解一种。  Unicode  作为一个额外的小知识，我顺便提及一下Unicode。Unicode也可以称为“Universal Coded Character Set”。为了结束各个国家，各个语种只为自己的语言字符编号的混乱局面。由国际组织主持编订了Unicode编码表。旨在为每一个人类语言符号提供一个独一无二的编码。无论拉丁字母，汉字，数学符号还是表情符号都能在表中查到。而且这个编码表会不断更新，以求不断补充完善。如果所有语言的文本文件在编码的时候都遵从Unicode的规定，就不会存在字符编码冲突的问题。  但是注意，Unicode只是一个字符表。表中尽量包含所有人类所用的语言符号，并且每一个字符都有一个独一无二的编码。但是这不意味着我们在计算机中必须直接用Unicode的字符编号来存储字符。直接用Unicode存储起码存在两个问题：  Unicode的符号总量一直在增长，需要用几位数字并不确定。可能这几年用六位二进制数就够了，过几年用八位二进制数都不够。 对于所用字符比较少的语言来说很多位是没有必要的。比如英文只用26个字母的大小写加一些标点符号。其实八位二进制足够了。但是Unicode字符编码的全长可远远不止八个二进制位。  UTF  UTF全称是Unicode Transformation Format。这是一套将Unicode字符编号转化为变长编码的方案。根据编码长度的基本单位不同，分为好几个版本。如果以8位（1个字节）为基本长度单位，那么就是UTF-8。如果以16位（2个字节）为基本长度单位，那么就是UTF-16。如果以32位（4个字节）为基本长度单位，那么就是UTF-32。我们以最普及，最常用的UTF-8为例介绍。  UTF-8以8位为基本长度单位。所以最短的UTF-8编码，也是8位表示一个字符。而排号比较靠后的编码就会比较长。当8位二进制数快用尽时，就再加上8位。当16位二进制数也快用进时就再加上8位。当24位二进制数又快用进时就再加上8位。再不够用就再加长。但是每次加长都是以8位为一个单位。  具体从Unicode编号到若干个字节组成的编码的转换方法见维基百科上的[UTF-8](https://en.wikipedia.org/wiki/UTF-8)条目。  几点注意事项：  UTF-8，UTF-16，UTF-32之间并不能直接相互转化。因为所采用的长度单位不同，所以最终转换出来的编码大概率不同。 由于微软的Windows系统中一直用“Unicode”称呼UTF-16，所以造成了非常大的混淆。一定要明确一个字符的UTF-16编码不等同于其Unicode编号。但是在Windows系统中有的写着Unicode的地方实际上是指UTF-16。  BOM的问题  现在一般的计算机都以8位为一个字节。所以UTF-16以上的编码方案（长度单位大于等于16的UTF编码方案）中都存在一个存储顺序的问题。比如UTF-16中每一节16位的编码都要拆成2个字节存储，占用2个字节的相邻内存单元。可以把高8位存储在高地址号的单元中，也可以反过来把高8位存储在低地址号的内存单元中。这样就又造成了分歧和不统一。不过大部分这种细节都被操作系统或者文本编辑器屏蔽了。作为用户倒是不用太操心这种问题。  为了说明存储顺序的问题，一般会在这些编码的文件头中加入BOM（Byte Order Mark）。也就是用开头几个字节的内容表示编码的存储方式。UTF-8也允许在文件头加入BOM。但是由于UTF-8根本不存在字节存储顺序的问题，所以不加BOM才是常用形式。一般情况下，不建议保存为带BOM的UTF-8。我们说到UTF-8的时候也一般是指不带BOM的形式。  之所以UTF-8的BOM成了一个问题，是因为一些Windows上的软件非要给UTF-8加上BOM。这样保存的文件拿到其他系统，用默认不带BOM的软件打开就会遭遇麻烦。  ASCII  ASCII是一套早在用电传打字机的时代就制定出来的一套字符编码方案。ASCII不是变长编码，1个字符8位二进制数。但是最高位留空，实际上只用了128个编号。出于尽量兼容已有编码方案的考虑，UTF-8的前128个字符和ASCII是基本一致的。  ASCII在制定时除了表示可以书写打印的所谓“可打印字符”（Printable Characters），还包括了一些控制打字机的控制命令。但是随着电传打字机的废弃，这些命令也大多停用了。虽然编号仍然留在ASCII中，但现在基本用不到。  目前仍然在用的几个控制符号在字符终端中被重新赋予了意义。关于这些控制字符在字符终端的意义请参考[VT-100字符终端的使用说明](https://vt100.net/docs/vt100-ug/)。  为了写代码方便，C语言中有一些通用的转义字符串被用来表示它们。比如`\t`表示水平制表，`\n`表示换行，`\r`表示回车。大部分编程语言中表示这些控制字符的方法都和C语言一致。一些文档或者手册中则用caret notation的约定来表示不可打印的控制字符。详细可以在维基百科的[ASCII](https://en.wikipedia.org/wiki/ASCII)条目中查到。  换行问题  电传打字机把换行打字分解为打字头回到最左端和纸张移动一行这两个动作。对应于这两个动作，分别使用`\r`和`\n`两个控制命令表示。到了计算机时代，字符终端也可以显示换行。但是工程师们在怎么表示换行的问题上产生了分歧。主流的观点就用三种。一种延续打字机的做法用`\r\n`表示（Windows的做法），一种认为只用`\r`就够了（Mac的做法），一种认为只用`\n`就够了（Unix，Linux的做法）。另外还有奇葩想用`\n\r`表示。  这种争论是永远没有终点的。主流的编辑器一般兼容以上所有的表示方法。我个人的意见是和Unix/Linux保持一致，使用`\n`。  吐槽 微软真的是麻烦制造者。换行符的问题，BOM的问题，混淆UTF-16和Unicode的问题都和微软的Windows有关。  编码和信息量的问题  字符编码的长度会影响到文本文件的大小。比如一个汉字在GBK中占2个字节，但在UTF-8中占3个字节。这样用UTF-8编码保存的文本是GBK格式汉字文本的约1.5倍。  但是，个人仍然建议所有非英文文本都用UTF-8保存，尤其是一些存在国际交流的场合。否则很可能遇到编码识别不了的尴尬。  而且在现在，由于编码方式造成的文件大小的差异其实无关紧要。一方面存储器很便宜了，没必要锱铢必较。另一方面，可以压缩来减少文件占用的空间。根据我的实验，GBK编码的汉字文本和UTF-8编码的汉字文本压缩后体积差不多大。因为虽然编码格式不同，但是信息量是差不多的。UTF-8中虽然汉字占了3个字节，但是每个汉字的UTF-8编码的最高几位都是相同的。压缩的时候这些重复的东西就会被压缩掉。  小节  综上本节所述，推荐的文本编码要符合以下要求：  UTF-8编码（不带BOM）。 LF（`\n`）表示换行。  由于UTF-8可以视为ASCII的超集，所以ASCII编码的纯英文文本也可以视为是UTF-8编码的。

作者：知则
https://www.bilibili.com/read/cv1331285
出处： bilibili